\chapter{Background}
\label{sec:back}

%\cleanchapterquote{TODO.}{TODO}{(TODO)}


In this chapter we give an overview on interactive kiosk systems, reactive programming, and graph data structures.

\section{Interactive Kiosk}


As defined by \cite{satish2012money}, ``an interactive kiosk is a computer terminal featuring specialized hardware and software designed within a public exhibit that provides access to information and applications for communication, commerce, entertainment, and education.''
By integrating emerging technologies, kiosks can perform a wide range of functions, evolving into self-service kiosks.
The main types of self-service kiosks of telephony, financial services, photo, internet access, ticketing and information kiosk.
According to \cite{kelsen2012unleashing}, ``historically electronic kiosks are standalone enclosures which accept user input, integrate many devices, include a software GUI application and remote monitoring and are deployed widely across all industry verticals.'' 

The reduction of costs, increasing revenue opportunities, and improvement customer service are the main goals of companies in a range of industries \cite{rigby2015management}.
Interactive kiosks has been used as an additional channel to enable their customers with self-service options, matching in this way the primarily goals those companies. 
According to \cite{abi16}, by 2016 the number of interactive kiosks in operation will rise from approximately 1.6 million deployed in 2011 to nearly 3 million deployed globally.
While the interactive kiosk market is expected to grow strongly, there remain challenges to address.
Reliability is an important consideration.
Many specialised kiosk software applications have been developed for the industry \cite{kelsen2012unleashing}. 
%http://www.kioskmarketplace.com/whitepapers/software-security-the-importance-of-locking-down-your-self-service-kiosk/


%The kiosk industry is divided into three segments: kiosk hardware, kiosk software, and kiosk application. 
%Kiosk software locks down your operating system (be it Apple, Windows, Android, or Linux) to restrict access and/or functionality of a kiosk hardware device. 
%This allows for users to interact with an application that serves a self-service purpose such as those mentioned above.
%Kiosk manufacturing industry

%According to \cite{kelsen2012unleashing}, historically electronic kiosks are standalone enclosures which accept user input, integrate many devices, include a software GUI application and remote monitoring and are deployed widely across all industry verticals. 
%Simple touchscreen terminals or panel-pcs are another segment and enjoy most of their footprint in POS retail applications and typically facing the employee. 
%Terminals include NCR Advantage (740x terminal) and the IBM Anyplace computer terminal. T
%hese units are considered "kiosks" only in functionality delivered and typically only incorporate touchscreen, bar code scanner and/or magnetic stripe reader.



\section{Reactive Programming}

In 2001, after the the bursting of the dot-com com bubble, the Web 2.0 phenomenon appeared and a survival way to the recent collapse \cite{oreilly2005}.
New applications aimed to involve the user on the content creation process.
One way of engaging the user is to offer a familiar environment, a similar to the one used in a desktop computer.
Web platforms and frameworks made use of \emph{reactive programming} \cite{reactive2014} to achieve a desktop-like experience on the web.
A consequence of turning the content creation responsibility to the user is the massive amount of data created by them, which originated another phenomenon called \emph{big data} \cite{SharmaTWGS14}.
In order to manage all these data, new paradigms emerged.
\emph{Non-relational} or \emph{No-SQL} \cite{Strauch12} is a database paradigm that manage the data storage and retrieval without using a relational table.
Novel web platforms and frameworks had to incorporate these new aspects in order to model and maintain the complexity requirement of the new applications.

\section{Graph Data Structures}


Graphs are a fundamental data structure in the world of programming.
Knowing the correct data structures to use with graph problems is critical \cite{topcoder}.
Graphs can represent many different types of systems.
A graph consists of two components: nodes and edges. 
A node (or vertex) is a discrete position in the graph. 
An edge (or connection) is a link between two vertices that can be either directed or undirected and may have a cost associated with it. 
An undirected edge means that there is no restriction on the direction you can travel along the edge. 
Formally, a \emph{graph} $G = {V, E}$ is defined as a set of vertices, $V$, and a collection of edges (which is not necessarily a set), $E$ \cite{berge1973graphs}.
An edge can then be defined as $(u, v)$ where $u$ and $v$ are elements of $V$.
%There are a few technical terms that it would be useful to discuss at this point as well:
%
%Order – The number of vertices in a graph Size – The number of edges in a graph

\subsection{Trees}

A tree is an undirected graph in which any two vertices are connected by exactly one path. 
Thus, a acyclic connected graph is also a tree.


\subsection{Basic methods for searching graphs}


There are two methods for searching graphs that are prevalent: \emph{Depth First Search} and the \emph{Breadth First Search}.
In this section, all steps are drawn from \cite{joyner2010algorithmic}.
For more details, please refer back to the original source.


\subsubsection{Breadth-first search}

Breadth-first search (BFS) is a strategy for running through the
vertices of a graph. 
It was presented by Moore \cite{moore1959shortest} in 1959 within the context of traversing mazes. 
Lee \cite{lee1961algorithm} independently discovered the same algorithm in 1961 in his work on routing wires on circuit boards.

The basic BFS algorithm can be described as follows. 
Starting from a given vertex $v$ of a graph $G$, we first explore the neighbourhood of $v$ by visiting all vertices that are adjacent to $v$. 
We then apply the same strategy to each of the neighbours of $v$. The strategy of exploring the neighbourhood of a vertex is applied to all vertices of $G$. 
The result is a tree rooted at $v$ and this tree is a subgraph of
$G$. 
Algorithm~ \ref{alg:graph_algorithms:breadth_first_search_template}
presents a general template for the BFS strategy. The tree resulting
from the BFS algorithm is called a \emph{breadth-first search tree}.

%todo fix alg
%\begin{algorithm}[!htpb]
%\DontPrintSemicolon
%\SetAlgoNoLine
%%%
%%% input
%\KwIn{A directed or undirected graph $G = (V, E)$ of order $n > 0$. A
%  vertex $s$ from which to start the search. The vertices are numbered
%  from $1$ to  $n = |V|$, i.e.~$V = \{1, 2, \dots, n\}$.}
%%%
%%% output
%\KwOut{A list $D$ of distances of all vertices from $s$. A tree $T$
%  rooted at $s$.}
%\BlankLine
%%%
%%% algorithm body
%$Q \assign [s]$\nllabel{alg:BFS:initialize_queue_visit_nodes}\tcc*[f]{queue of nodes to visit}\;
%$D \assign [\infty, \infty, \dots, \infty]$\tcc*[f]{$n$ copies of $\infty$}\;
%$D[s] \assign 0$\;
%$T \assign [\,]$\nllabel{alg:BFS:initialize_empty_tree}\;
%\While{$\length(Q) > 0$\nllabel{alg:BFS:while_loop:non_empty_queue}}{
%  $v \assign \dequeue(Q)$\;
%  \For{\rm each $w \in \adj(v)$\nllabel{alg:BFS:explore_neighborhood}}{
%    \If{$D[w] = \infty$\nllabel{alg:BFS:marking_vertex_as_visited}}{
%      $D[w] \assign D[v] + 1$\;
%      $\enqueue(Q, w)$\;
%      $\append(T, vw)$\nllabel{alg:BFS:while_loop:append_to_tree}\;
%    }
%  }
%}
%\Return $(D, T)$\;\caption{A general breadth-first search template.}
%\label{alg:graph_algorithms:breadth_first_search_template}
%\end{algorithm}

The breadth-first search algorithm makes use of a special type of list called a \emph{queue}. 
Formally, a queue $Q$ is a list of elements. 
At any time, we only have access to the first element of $Q$, known as the \emph{front} or \emph{start} of the queue. We insert
a new element into $Q$ by appending the new element to the \emph{rear} or \emph{end} of the queue. 
The operation of removing the front of $Q$ is referred to as \emph{dequeue}, while the operation of appending to the rear of $Q$ is called \emph{enqueue}. 
That is, a queue implements a first-in first-out~(FIFO) protocol for adding and moving elements. 
As with lists, the \emph{length} of a queue is its total number of elements.

\subsubsection{Depth-first search}


A depth-first search~(DFS) is a graph traversal strategy similar to
breadth-first search. Both BFS and DFS differ in how they explore each
vertex. Whereas BFS explores the neighbourhood of a vertex $v$ before
moving on to explore the neighbourhoods of the neighbours, DFS explores
as deep as possible a path starting at $v$. One can think of BFS as
exploring the immediate surrounding, while DFS prefers to see what is
on the other side of the hill. In the 19th century,
Lucas and Tarry investigated DFS as a strategy for traversing mazes. 
Fundamental properties of DFS were discovered in the early 1970s by Hopcroft and Tarjan \cite{schrijver2012history}.


%\begin{algorithm}[!htpb]
%\DontPrintSemicolon
%\SetAlgoNoLine
%%%
%%% input
%\KwIn{A directed or undirected graph $G = (V, E)$ of order $n > 0$. A
%  vertex $s$ from which to start the search. The vertices are numbered
%  from $1$ to  $n = |V|$, i.e.~$V = \{1, 2, \dots, n\}$.}
%%%
%%% output
%\KwOut{A list $D$ of distances of all vertices from $s$. A tree $T$
%  rooted at $s$.}
%\BlankLine
%%%
%%% algorithm body
%$S \assign [s]$\tcc*[f]{stack of nodes to visit}\;
%$D \assign [\infty, \infty, \dots, \infty]$\tcc*[f]{$n$ copies of $\infty$}\;
%$D[s] \assign 0$\;
%$T \assign [\,]$\;
%\While{$\length(S) > 0$\nllabel{alg:DFS:while_loop_tests_non_empty_stack}}{
%  $v \assign \pop(S)$\;
%  \For{\rm each $w \in \adj(v)$\nllabel{alg:DFS:for_loop_visit_neighbors}}{
%    \If{$D[w] = \infty$\nllabel{alg:DFS:if_test_unvisited_neighbors}}{
%      $D[w] \assign D[v] + 1$\;
%      $\push(S, w)$\;
%      $\append(T, vw)$\;
%    }
%  }
%}
%\Return $(D, T)$\;
%
%
%\caption{A general depth-first search template.}
%\label{alg:graph_algorithms:depth_first_search_template}
%\end{algorithm}

Algorithm~\ref{alg:graph_algorithms:depth_first_search_template}
formalizes the above description of depth-first search. The tree
resulting from applying DFS on a graph is called a
\emph{depth-first search tree}. The general structure of this
algorithm bears close resemblance to
Algorithm~\ref{alg:graph_algorithms:breadth_first_search_template}. A
significant difference is that instead of using a queue to structure
and organize vertices to be visited, DFS uses another special type of
list called a \emph{stack}. A list $L = [a_1, a_2, \dots, a_k]$ of $k$
elements is a stack when we impose the same rules for element
insertion and removal. The top and bottom of the stack are $L[k]$ and
$L[1]$, respectively. The operation of removing the top element of the
stack is referred to as \emph{popping} the element off the
stack. Inserting an element into the stack is called \emph{pushing}
the element onto the stack. In other words, a stack implements a
last-in first-out~(LIFO) protocol for element insertion and removal,
in contrast to the FIFO policy of a queue. We also use the term
\emph{length} to refer to the number of elements in the stack.

%\section{Resource Constrains}
